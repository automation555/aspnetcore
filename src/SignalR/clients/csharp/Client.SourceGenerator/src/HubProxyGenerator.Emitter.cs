using System;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace Microsoft.AspNetCore.SignalR.Client.SourceGenerator
{
    internal partial class HubProxyGenerator
    {
        public class Emitter
        {
            private readonly GeneratorExecutionContext _context;
            private readonly SourceGenerationSpec _spec;

            public Emitter(GeneratorExecutionContext context, SourceGenerationSpec spec)
            {
                _context = context;
                _spec = spec;
            }

            public void Emit()
            {
                EmitExtensions();
                foreach (var classSpec in _spec.Classes)
                {
                    EmitProxy(classSpec);
                }
            }

            private void EmitExtensions()
            {
                var getProxyBody = new StringBuilder();

                foreach (var classSpec in _spec.Classes)
                {
                    var fqIntfTypeName = classSpec.FullyQualifiedInterfaceTypeName;
                    var fqClassTypeName = classSpec.FullyQualifiedClassTypeName;
                    getProxyBody.Append($@"
            if(typeof(THub) == typeof({fqIntfTypeName})) return (THub) ({fqIntfTypeName}) new {fqClassTypeName}(conn);");
                }

                var getProxy = $@"// Generated by Microsoft.AspNetCore.Client.SourceGenerator
using Microsoft.AspNetCore.SignalR.Client;
namespace Microsoft.AspNetCore.SignalR.Client
{{
    public static partial class HubConnectionExtensionsGenerated
    {{
        public static THub GetProxy<THub>(this IHubConnection conn)
        {{
{getProxyBody.ToString()}
            throw new System.ArgumentException(nameof(THub));
        }}
    }}
}}";

                _context.AddSource("HubProxy.g.cs", SourceText.From(getProxy.ToString(), Encoding.UTF8));
            }

            private void EmitProxy(ClassSpec classSpec)
            {
                var methods = new StringBuilder();

                foreach (var methodSpec in classSpec.Methods)
                {
                    var signature = new StringBuilder($"public {methodSpec.FullyQualifiedReturnTypeName} {methodSpec.Name}(");
                    var callArgs = new StringBuilder("");
                    var signatureArgs = new StringBuilder("");
                    var first = true;
                    foreach (var argumentSpec in methodSpec.Arguments)
                    {
                        if (!first)
                        {
                            signatureArgs.Append(", ");
                        }

                        first = false;
                        signatureArgs.Append($"{argumentSpec.FullyQualifiedTypeName} {argumentSpec.Name}");
                        callArgs.Append($", {argumentSpec.Name}");
                    }
                    signature.Append(signatureArgs);
                    signature.Append(')');

                    // Prepare method body
                    var body = "";
                    if (methodSpec.Support != SupportClassification.Supported)
                    {
                        body = "throw new System.NotSupportedException();";
                    }
                    else
                    {
                        // Get specific hub connection extension method call
                        var specificCall = getSpecificCall(methodSpec);

                        // Handle ValueTask
                        var prefix = "";
                        var suffix = "";
                        if (methodSpec.IsReturnTypeValueTask)
                        {
                            if (methodSpec.InnerReturnTypeName is not null)
                            {
                                prefix = $"new System.Threading.Tasks.ValueTask<{methodSpec.InnerReturnTypeName}>(";
                            }
                            else
                            {
                                prefix = "new System.Threading.Tasks.ValueTask(";
                            }
                            suffix = $")";
                        }

                        // Bake it all together
                        body = $"return {prefix}this.conn.{specificCall}(\"{methodSpec.Name}\"{callArgs}){suffix};";
                    }

                    var method = $@"
        {signature}
        {{
            {body}
        }}
";
                    methods.Append(method);
                }

                var proxy = $@"// Generated by Microsoft.AspNetCore.Client.SourceGenerator
using Microsoft.AspNetCore.SignalR.Client;
namespace Microsoft.AspNetCore.SignalR.Client.SourceGenerated
{{
    public sealed class {classSpec.ClassTypeName} : {classSpec.FullyQualifiedInterfaceTypeName}
    {{
        private IHubConnection conn;
        public {classSpec.ClassTypeName}(IHubConnection conn)
        {{
            this.conn = conn;
        }}
{methods.ToString()}
    }}
}}";

                _context.AddSource($"HubProxy.{classSpec.ClassTypeName}.g.cs", SourceText.From(proxy.ToString(), Encoding.UTF8));
            }

            private string getSpecificCall(MethodSpec methodSpec)
            {
                if (methodSpec.Stream.HasFlag(StreamSpec.ServerToClient) &&
                    !methodSpec.Stream.HasFlag(StreamSpec.AsyncEnumerable))
                {
                    return $"StreamAsChannelAsync<{methodSpec.InnerReturnTypeName}>";
                }

                if (methodSpec.Stream.HasFlag(StreamSpec.ServerToClient) &&
                    methodSpec.Stream.HasFlag(StreamSpec.AsyncEnumerable))
                {
                    return $"StreamAsync<{methodSpec.InnerReturnTypeName}>";
                }

                if (methodSpec.Stream.HasFlag(StreamSpec.ClientToServer))
                {
                    return "SendAsync";
                }

                if (methodSpec.InnerReturnTypeName is not null)
                {
                    return $"InvokeAsync<{methodSpec.InnerReturnTypeName}>";
                }

                return "InvokeAsync";
            }
        }
    }
}
