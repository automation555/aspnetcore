using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Microsoft.AspNetCore.SignalR.Client.SourceGenerator
{
    [Generator]
    internal class CallbackRegistrationGenerator : ISourceGenerator
    {
        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
        }

        public void Execute(GeneratorExecutionContext context)
        {
            var registerProviderBody = new StringBuilder(@"// Generated by Microsoft.AspNetCore.Client.SourceGenerator
using Microsoft.AspNetCore.SignalR.Client;
namespace Microsoft.AspNetCore.SignalR.Client
{
    public static partial class HubConnectionExtensionsGenerated
    {
        public static System.IDisposable RegisterCallbackProvider<T>(this IHubConnection conn, T provider)
        {");
            var registerProviderFooter = @"
            throw new System.ArgumentException(nameof(T));
        }

        private sealed class CallbackProviderRegistration : System.IDisposable
        {
            private System.IDisposable[] registrations;
            public CallbackProviderRegistration(params System.IDisposable[] registrations)
            {
                this.registrations = registrations;
            }

            public void Dispose()
            {
                if(this.registrations is null) return;
                System.Collections.Generic.List<System.Exception> exceptions = null;
                foreach(var registration in this.registrations)
                {
                    try
                    {
                        registration.Dispose();
                    }
                    catch (System.Exception exc)
                    {
                        if(exceptions is null) exceptions = new ();
                        exceptions.Add(exc);
                    }
                }
                this.registrations = null;
                if(exceptions is not null) throw new System.AggregateException(exceptions);
            }
        }
    }
}";

            if (context.SyntaxReceiver is not SyntaxReceiver receiver)
            {
                // nothing to do yet
                registerProviderBody.Append(registerProviderFooter);
                context.AddSource("GeneratedBy" + nameof(CallbackRegistrationGenerator),
                    SourceText.From(registerProviderBody.ToString(), Encoding.UTF8));
                return;
            }

            var providerSymbols = new Dictionary<string, (ITypeSymbol, MemberAccessExpressionSyntax)>();
            var iHubConnectionType =
                context.Compilation.GetTypeByMetadataName("Microsoft.AspNetCore.SignalR.Client.IHubConnection");

            // Go thru candidates and filter
            foreach(var memberAccess in receiver.Candidates)
            {
                var expressionModel = context.Compilation.GetSemanticModel(memberAccess.Expression.SyntaxTree);
                var typeInfo = expressionModel.GetTypeInfo(memberAccess.Expression);

                // Filter based on receiver symbol
                if(!SymbolEqualityComparer.Default.Equals(typeInfo.Type, iHubConnectionType) &&
                   (typeInfo.Type.AllInterfaces.IsDefaultOrEmpty ||
                    !typeInfo.Type.AllInterfaces.Any(x => SymbolEqualityComparer.Default.Equals(x, iHubConnectionType))))
                {
                    // Member access is not acting on IHubConnection or a type implementing it; as such we will skip
                    continue;
                }

                // Extract type symbol
                ITypeSymbol symbol;
                if (memberAccess.Name is GenericNameSyntax {Arity: 1} gns)
                {
                    // Method is using generic syntax so the sole generic arg is the type
                    var argType = gns.TypeArgumentList.Arguments[0];
                    var argModel = context.Compilation.GetSemanticModel(argType.SyntaxTree);
                    symbol = (ITypeSymbol) argModel.GetSymbolInfo(argType).Symbol;
                }
                else if (memberAccess.Name is not GenericNameSyntax
                         && memberAccess.Parent.ChildNodes().FirstOrDefault(x => x is ArgumentListSyntax) is ArgumentListSyntax
                         { Arguments: {Count: 1} } als)
                {
                    // Method isn't using generic syntax so inspect first expression in arguments to deduce the type
                    var argModel = context.Compilation.GetSemanticModel(als.Arguments[0].Expression.SyntaxTree);
                    var argTypeInfo = argModel.GetTypeInfo(als.Arguments[0].Expression);
                    symbol = argTypeInfo.Type;
                }
                else
                {
                    // If we are here then candidate has different number of args than we expect so we skip
                    continue;
                }

                // Receiver is a IHubConnection, so save argument symbol for generation
                providerSymbols[symbol.Name] = (symbol, memberAccess);
            }

            // Generate registration methods for all the callback provider types detected previously
            var registrationBody = new StringBuilder(@"
namespace Microsoft.AspNetCore.SignalR.Client
{
    public static partial class HubConnectionExtensionsGenerated
    {");

            foreach (var (providerSymbol, memberAccess) in providerSymbols.Values)
            {
                var typeName = $"Generated{providerSymbol.Name}";
                var members = providerSymbol.GetMembers()
                    .Where(member => member.Kind == SymbolKind.Method)
                    .Select(member => (IMethodSymbol) member)
                    .Union<IMethodSymbol>(providerSymbol.AllInterfaces.SelectMany(x => x
                        .GetMembers()
                        .Where(member => member.Kind == SymbolKind.Method)
                        .Select(member => (IMethodSymbol) member)), SymbolEqualityComparer.Default).ToList();

                registrationBody.AppendLine($@"
        private static System.IDisposable[] register{providerSymbol.Name}(IHubConnection conn, {providerSymbol.ToString()} provider)
        {{
            var registrations = new System.IDisposable[{members.Count}];");

                // Generate each of the methods
                var i = 0;
                foreach (var member in members)
                {
                    var genericArgs = new StringBuilder();
                    var lambaParams = new StringBuilder();

                    // Populate call with its parameters
                    var first = true;
                    foreach (var parameter in member.Parameters)
                    {
                        if (first)
                        {
                            genericArgs.Append('<');
                            lambaParams.Append('(');
                        }
                        else
                        {
                            genericArgs.Append(", ");
                            lambaParams.Append(", ");
                        }

                        first = false;
                        genericArgs.Append($"{parameter.Type}");
                        lambaParams.Append($"{parameter.Name}");
                    }

                    if (!first)
                    {
                        genericArgs.Append('>');
                        lambaParams.Append(')');
                    }
                    else
                    {
                        lambaParams.Append("()");
                    }


                    var lambda = $"{lambaParams} => provider.{member.Name}{lambaParams}";
                    var call = $"conn.On{genericArgs}(\"{member.Name}\", {lambda})";

                    registrationBody.AppendLine($@"
            registrations[{i}] = {call};");
                    ++i;
                }
                registrationBody.AppendLine(@"
            return registrations;
        }");
            }
            registrationBody.AppendLine(@"
    }
}");

            // Populate RegisterCallbackProvider<T> with calls to appropriate registration methods
            foreach (var (providerSymbol, memberAccess) in providerSymbols.Values)
            {
                var methodName = $"register{providerSymbol.Name}";
                registerProviderBody.AppendLine($@"
            if(typeof(T) == typeof({providerSymbol})) return (System.IDisposable) new CallbackProviderRegistration({methodName}(conn, ({providerSymbol}) provider));");
            }

            registerProviderBody.AppendLine(registerProviderFooter);
            registerProviderBody.AppendLine(registrationBody.ToString());

            context.AddSource("GeneratedBy" + nameof(CallbackRegistrationGenerator),
                SourceText.From(registerProviderBody.ToString(), Encoding.UTF8));
        }

        private class SyntaxReceiver : ISyntaxReceiver
        {
            public List<MemberAccessExpressionSyntax> Candidates { get; } = new();

            public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
            {
                if (syntaxNode is MemberAccessExpressionSyntax
                {
                    Name:
                    {
                        Identifier:
                        {
                            ValueText: "RegisterCallbackProvider"
                        }
                    }
                } registrationCall)
                {
                    Candidates.Add(registrationCall);
                }
            }
        }
    }
}
